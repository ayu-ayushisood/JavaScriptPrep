{
    "topic": "Javascript",
    "importantLinks": ["https://www.w3schools.com", "www.fb.com"],
    "logo": "https://javascript-prep.s3.ap-south-1.amazonaws.com/JavaScript-logo.png",
    "questionsAndAnswers":[{
        "question": "<h3>Hoisting</h3>",
        "answer": "Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution regardless of whether their scope is global or local. Every time you write a program in javascript, it runs in an environment and that environment is called execution context. There are two types of execution contexts: <ul><li>Global Execution Context</li><li>Execution Context created every time after a function is created. Every time a function is called the new execution context is pushed to the top of the global execution context, which makes an execution stack.</li></ul>An undeclared variable is assigned the value undefined at execution and is also type undefined. A ReferenceError is thrown when trying to access a previously undeclared variable.<br>Function declarations are hoisted and Function expressions are not .. gives typeError"
    }, {
        "question": "<h3>JavaScript Functions</h3>",
        "answer": "<p>2 types of JS functions</p><ol><li>Function declaration and 2. Function Expression</li><li>The Function Declaration is created when JavaScript is preparing to start the script and is visible everywhere in it.<code>function foo(){}</code></li><li>Function Expressions are created when the execution reaches them.<code>let foo = function(){}</code>Difference</li><li>Syntax</li><li>The main difference between a function expression and a function declaration is the function name, which can be omitted in function expressions to create anonymous functions.</li><li>FE can be used as an IIFE.*can&#39;t use function expression before creating them (because they are not hoisted).</li></ol>"
    }, {
        "question": "<h3>Closures</h3>",
        "answer": "<p>A closure is an inner function which gives you access to an outer functionâ€™s scope from inside even before the function is returned. In JavaScript, closures are created every time a function is created, at function creation time. A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope at the time the closure was created.</p> <p>what happens internally is: outer function execution goes into the execution stack first, then the variables goes into symbols table. Variable remains there till the execution of the function is completed. Then comes the inner function, it goes in execution stack and can access variable from symbols table. Once the execution of outer function is completed you can&#39;t access the variable outside. Also, you can&#39;t access the variables declared inside the inner function. <code>function runExecution() { var a = 10; function add(b){ var b = 20;return a + b;} add();}</code></p><p>Further explanation to that &quot;reference&quot; concept: Point 1: &quot;An object is marked as eligible to be garbage collected when it can no longer be accessed.&quot; As you can&#39;t initiate garbage collection process manually in javascript, JS engine determines the eligibility of an object for GC using the above mentioned point. FYI, this is applicable for all types of objects.</p><p>But if there&#39;s a reference somewhere, which means if it can still be accessed (In case of closure, inner function still has reference preserved for variables defined in outer function), which means it still stays in the Heap memory &amp; garbage collector doesn&#39;t consider these variables.</p> "
    }]
}