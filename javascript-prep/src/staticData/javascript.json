{
    "topic": "Javascript",
    "importantLinks": ["https://www.w3schools.com", "www.fb.com"],
    "logo": "https://javascript-prep.s3.ap-south-1.amazonaws.com/JavaScript-logo.png",
    "questionsAndAnswers":[{
        "question": "<h3>Hoisting</h3>",
        "answer": "Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution regardless of whether their scope is global or local. Every time you write a program in javascript, it runs in an environment and that environment is called execution context. There are two types of execution contexts: <ul><li>Global Execution Context</li><li>Execution Context created every time after a function is created. Every time a function is called the new execution context is pushed to the top of the global execution context, which makes an execution stack.</li></ul>An undeclared variable is assigned the value undefined at execution and is also type undefined. A ReferenceError is thrown when trying to access a previously undeclared variable.<br>Function declarations are hoisted and Function expressions are not .. gives typeError"
    }, {
        "question": "<h3>JavaScript Functions</h3>",
        "answer": "<p>2 types of JS functions</p><ol><li>Function declaration and 2. Function Expression</li><li>The Function Declaration is created when JavaScript is preparing to start the script and is visible everywhere in it.<code>function foo(){}</code></li><li>Function Expressions are created when the execution reaches them.<code>let foo = function(){}</code>Difference</li><li>Syntax</li><li>The main difference between a function expression and a function declaration is the function name, which can be omitted in function expressions to create anonymous functions.</li><li>FE can be used as an IIFE.*can&#39;t use function expression before creating them (because they are not hoisted).</li></ol>"
    }, {
        "question": "<h3>Closures</h3>",
        "answer": "<p>A closure is an inner function which gives you access to an outer function’s scope from inside even before the function is returned. In JavaScript, closures are created every time a function is created, at function creation time. A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope at the time the closure was created.</p> <p>what happens internally is: outer function execution goes into the execution stack first, then the variables goes into symbols table. Variable remains there till the execution of the function is completed. Then comes the inner function, it goes in execution stack and can access variable from symbols table. Once the execution of outer function is completed you can&#39;t access the variable outside. Also, you can&#39;t access the variables declared inside the inner function. <code>function runExecution() { var a = 10; function add(b){ var b = 20;return a + b;} add();}</code></p><p>Further explanation to that &quot;reference&quot; concept: Point 1: &quot;An object is marked as eligible to be garbage collected when it can no longer be accessed.&quot; As you can&#39;t initiate garbage collection process manually in javascript, JS engine determines the eligibility of an object for GC using the above mentioned point. FYI, this is applicable for all types of objects.</p><p>But if there&#39;s a reference somewhere, which means if it can still be accessed (In case of closure, inner function still has reference preserved for variables defined in outer function), which means it still stays in the Heap memory &amp; garbage collector doesn&#39;t consider these variables.</p> "
    },{
        "question": "<h3>Spread and Rest operator</h3>",
        "answer": "<p>The spread operator takes an array (or any iterable) and spreads its values. The spread operator takes the array of parameters and spreads them across the arguments in the function call. But what if we need our function to be able to work with an unknown number of parameters? That’s where the rest parameter comes in. The rest parameter gives us an easier and cleaner way of working with an indefinite number of parameters</p> <p><strong>Arguments</strong> is like rest operator, it was used in old javascript but the difference between these both is, arguments creates an array like structure but not array, so we can&#39;t use methods of array, for example array.map(..)</p></p> <ul> <li>Spread syntax internally uses iterator, as for...of</li> <li>Rest parameters are used to create functions that accept any number of arguments.</li> <li>The spread syntax is used to pass an array to functions that normally require a list of many arguments.  </li> </ul> <p>Uses of spread operator-&gt; </p> <ul> <li>Make copies of array or object. </li> <li>Merge arrays</li></ul>"
    },{
        "question": "Differences between var and let",
        "answer": "<ol> <li>Scope: var variables are function scoped and let variables are block scoped.</li> <li>Hoisting: var variables are hoisted, let will throw referenceError.</li> <li>Global object: var variables are created as a global object i,e, are attached to window object, but let variables are not. (which means var are wasting memory attaching every variable to the global object.)</li> <li>Redeclaration:  <code>var foo = 20; var foo;</code> its ok but will throw an error in strict mode but <code>let bar = 20; let 20;</code> is not ok. </li> </ol>"
    }]
}