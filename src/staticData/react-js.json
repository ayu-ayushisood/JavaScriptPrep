{
    "topic": "ReactJS",
    "importantLinks": [{
        "link": "https://itnext.io/add-state-and-lifecycle-methods-to-function-components-with-react-hooks-8e2bdc44d43d", 
        "text": "Hooks for statefull functional components"
    },{
        "link": "https://medium.com/@Zwenza/functional-vs-class-components-in-react-231e3fbd7108",
        "text":"When to choose what components"
    }],
    "logo": "https://javascript-prep.s3.ap-south-1.amazonaws.com/react-logo.png",
    "questionsAndAnswers":[{
        "question": "React and Virtual Dom",
        "answer": "<p>React creates a virtual DOM. When state changes in a component it firstly runs a <strong>diffing</strong> algorithm, which identifies what has changed in the virtual DOM. The second step is reconciliation, where it updates the DOM with the results of diff. Whenever a ReactComponent is changing the state, diff algorithm in React runs and identifies what has changed. And then it updates the DOM with the results of diff. The point is - itâ€™s done faster than it would be in the regular DOM.</p> "
    }, {
        "question": "Lifecycle of react components",
        "answer": "<ul> <li><strong>Initialization</strong> where constructor function is called to set things up, generally states and props.</li> <li><strong>Mounting</strong> Component renders for the first time and 2 methods are available- <em>ComponentDidMount</em> and <em>ComponentWillMount</em>. How it happens is, willMount is called just before the render method and is called only once in the entire lifecycle. After render method didMount is called.</li> <li><strong>Updating</strong> where component&#39;s state and props changes and it re renders on the page. 4 methods are available at this time:</li> </ul> <p><em>componentWillReceiveProps</em> receives props, </p> <p> <em>ShouldComponentUpdate</em> is called just before the component is re rendered and tells whether the component should be updated or not. By default, it returns true.</p> <p><em>componentWillUpdate</em> it is called just before the new component gets rendered.</p> <p><em>componentDidUpdate</em> This method is called just after the re-rendering of the component. You will have access to the previous props and state with prevProp and prevState as well as the current ones, and you can use this method to update any third party libraries if they happen to need an update due to the re-render.</p> <ul> <li><strong>Unmounting</strong> : At the unmounting stage, the component gets deleted and removed from the page. The only lifecycle method at this stage is componentWillUnmount, which is called just before the component gets deleted. It is used to clear anything that was set up in componentDidMount</li> </ul> "
    }, {
        "question": "How does virtual DOM know what has changed in the list of elements",
        "answer": ""
    }, {
        "question": "React.createElement()",
        "answer": "<p><code>React.createElement( type, [props], [...children] )</code> Create and return a new React element of the given type. The type argument can be either a tag name string (such as &#39;div&#39; or &#39;span&#39;), a React component type (a class or a function), or a React fragment type.</p>"
    }, {
        "question": "React.createElement()",
        "answer": "<p><code>React.createElement( type, [props], [...children] )</code> Create and return a new React element of the given type. The type argument can be either a tag name string (such as &#39;div&#39; or &#39;span&#39;), a React component type (a class or a function), or a React fragment type.</p>"
    }, {
        "question": "Why React?",
        "answer": ""
    }, {
        "question": "How to make use of component lifecycle in functional methods",
        "answer": "Use React Hooks to use states in functional components. Read more about it in the important links section."
    }, {
        "question": "Differences between functional and class components",
        "answer": "Refer to the important links."
    }]
}